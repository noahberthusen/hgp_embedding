<html>
	<head>
		<script src="https://d3js.org/d3.v4.js"></script>
		<script src="decoder.js"></script>
		<!-- <script src="read_code.js"></script> -->
		<link rel="stylesheet" href="decoder.css"/>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">

	</head>
	<body>
		<div class="container-fluid">
			<div class="row">
				<div class="col-4">
					<form>
						<div class="row">
							<label>Physical error rate</label>
							<div class="col">
								<input type="text" class="form-control" id="p" value="0.01">
							</div>
							<div class="col">
								<button type="button" class="btn btn-secondary" onclick="randomError()">Generate random error</button>
							</div>
						</div>
						<div class="row">
							<label>Masking rate</label>
							<div class="col">
								<input type="text" class="form-control" id="p_mask" value="0.1">
							</div>
							<div class="col">
								<button type="button" class="btn btn-secondary" onclick="randomMask()">Generate random mask</button>
							</div>
						</div>
						<div class="row">
							<label>Manual error</label>
							<div class="col-10">
								<input type="text" id="errors" class="form-control" value="(0,1) (4,3) | (1,1)">
								<small class="form-text text-muted">
									Separate qubit error blocks by |, i.e. (0,1) (4,3) | (1,1) 
								</small>
							</div>
							<div class="col-2">
								<button type="button" class="btn btn-secondary" onclick="manualError()">
									<svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
										<path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
									</svg>
								</button>
							</div>
						</div>

						<div class="row">
							<label>Manual mask</label>
							<div class="col-10">
								<input type="text" id="mask" class="form-control" value="(2,2) (5,6)">
							</div>
							<div class="col-2">
								<button type="button" class="btn btn-secondary" onclick="manualMask()">
									<svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
										<path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
									</svg>
								</button>
							</div>
						</div>


						<div class="row">
							<div class="col">
								<button type="button" class="btn btn-secondary" onclick="clearAll()">Clear</button>
							</div>
						</div>
					</form>
				</div>
				<div class="col-6">
					<div id="code" style="text-align: center"></div>
				</div>
				<div class="col-2 right">
				</div>
			</div>
		</div>

		


	</body>
</html>

<script>



function qcodeData(code) {
	var n = 16
	var m = 12

	var bit_nbhd = [
	[5,7,10],
	[0,7,11],
	[2,5,8],
	[4,5,6],
	[1,6,11],
	[1,2,7],
	[2,3,11],
	[0,1,5],
	[0,3,10],
	[4,8,10],
	[9,10,11],
	[2,6,9],
	[0,8,9],
	[4,7,9],
	[3,6,8],
	[1,3,4,]
	]

	var check_nbhd = [
	[1,7,8,12],
	[4,5,7,15],
	[2,5,6,11],
	[6,8,14,15],
	[3,9,13,15],
	[0,2,3,7],
	[3,4,11,14],
	[0,1,5,13],
	[2,9,12,14],
	[10,11,12,13],
	[0,8,9,10],
	[1,4,6,10],
	]

	var vv = new Array()
	var cc = new Array()
	var z_gens = new Array()
	var x_gens = new Array()

	for (var i = 0; i < n; i++) {
		vv.push(new Array())
		for (var j = 0; j < n; j++) {
			vv[i].push({
				xind: j,
				yind: i,
				z_gen_nbhd: bit_nbhd[j],
				x_gen_nbhd: bit_nbhd[i],
				in_error: 0
			})
		}
	}

	for (var i = 0; i < m; i++) {
		cc.push(new Array())
		for (var j = 0; j < m; j++) {
			cc[i].push({
				xind: j,
				yind: i,
				z_gen_nbhd: check_nbhd[i],
				x_gen_nbhd: check_nbhd[j],
				in_error: 0
			})
		}
	}

	for (var i = 0; i < n; i++) {
		z_gens.push(new Array())
		for (var j = 0; j < m; j++) {
			z_gens[i].push({
				xind: j,
				yind: i,
				vv_nbhd: check_nbhd[j],
				cc_nbhd: bit_nbhd[i],
				in_synd: false,
				in_mask: false
			})
		}
	}

	for (var i = 0; i < m; i++) {
		x_gens.push(new Array())
		for (var j = 0; j < n; j++) {
			x_gens[i].push({
				xind: j,
				yind: i,
				vv_nbhd: check_nbhd[i],
				cc_nbhd: bit_nbhd[j],
				score: { best_flips: { ver_flips: [], hor_flips: [] }, best_synd_diff: 0, best_weight: 1 }
			})
		}
	}
	return {vv, cc, z_gens, x_gens}
}

var width = 600
var height = 600
var n = 16
var m = 12
var dc = 4
var dv = 3
var padding = 1.5

// var data = new Array()
var data = qcodeData()
var lt = new LookupTable(data.vv, data.cc, data.z_gens, data.x_gens, dv, dc)



	// https://stackoverflow.com/questions/37429608/can-i-have-a-svg-pattern-with-background-color

var myColor = d3.scaleLinear()
	.range(["white", "#00A7FF"])
  .domain([0, dc])

var colors = {
	"DarkRed": "#F44336", // dark red
	"LightRed": "#F88A81", // light red
	"Gray": "#9E9E9E", // gray
	"White": "#FFFFFF"
}

var randomError = function() {
	lt.randomError(d3.select("#p").property("value"))
	updateAll(lt)
}

var randomMask = function () {
	lt.randomMask(d3.select("#p_mask").property("value"))
	updateAll(lt)
}

var clearAll = function() {
	clearError()
	clearMask()
}

var clearError = function() {
	lt.randomError(0)
	updateAll(lt)
}

var clearMask = function() {
	lt.randomMask(0)
	updateAll(lt)
}

var manualError = function() {
	clearError()
	var errors = d3.select("#errors").property("value").trim().split('|')
	if (errors[0].length) {
		errors[0].trim().split(/\) *\(/).forEach(function (x, i) {
			var e = x.replace('(','').replace(')','').split(',')
			lt.vv[parseInt(e[0])][parseInt(e[1])].in_error = true
		})
	}
	if (errors[1].length) {
		errors[1].trim().split(/\) *\(/).forEach(function (x, i) {
			var e = x.replace('(','').replace(')','').split(',')
			lt.cc[parseInt(e[0])][parseInt(e[1])].in_error = true
		})
	}
	updateAll(lt)
}

var manualMask = function() {
	clearMask()
	d3.select("#mask").property("value").trim().split(/\) *\(/).forEach(function (x, i) {
		var m = x.replace('(','').replace(')','').split(',')
		lt.z_gens[parseInt(m[0])][parseInt(m[1])].in_mask = true
	})
	updateAll(lt)
}

var syndFill = function(gen, highlight) { 
	if (highlight) {
		if (gen.in_synd && gen.in_mask) { 
			return "url(#diagonalDarkRed)" 
		} 
		else if (gen.in_synd && !gen.in_mask) { return colors["DarkRed"] }
		else if (!gen.in_synd && gen.in_mask) { 
			return "url(#diagonalGray)" 
		}
		else { return colors["Gray"] }
	} else {
		if (gen.in_synd && gen.in_mask) { 
			return "url(#diagonalLightRed)" 
		} 
		else if (gen.in_synd && !gen.in_mask) { return colors["LightRed"] }
		else if (!gen.in_synd && gen.in_mask) { 
			return "url(#diagonalWhite)" 
		}
		else { return colors["White"] }
	}
}

var qubitFill = function(qbt, highlight) {
	if (highlight) {
		if (qbt.in_error) {
			return colors["DarkRed"]
		} else {
			return colors["Gray"]
		}
	} else {
		if (qbt.in_error) {
			return colors["LightRed"]
		} else {
			return colors["White"]
		}
	}
}

var selectedSmallSet = function (qbt, cx, cy, highlight) {
	var repeat = function() {
		var angle = 20
		var angles = [0, angle, 0, -angle, 0]
		var interpols = new Array()

		for (var i = 0; i < angles.length - 1; i++) {
			interpols.push(d3.interpolateString( `rotate(${angles[i]},${cx},${cy})`, `rotate(${angles[i+1]},${cx},${cy})` ))
		}

		var dur = Math.random() * (200 - 150) + 150
		d3.select(qbt).transition()
			.duration(dur)
			.attrTween("transform", function(d,i,a) { return interpols[0] })
			.transition()
			.duration(dur)
			.attrTween("transform", function(d,i,a) { return interpols[1] })
			.transition()
			.duration(dur)
			.attrTween("transform", function(d,i,a) { return interpols[2] })
			.transition()
			.duration(dur)
			.attrTween("transform", function(d,i,a) { return interpols[3] })
			.on("end", repeat)
	}

	if (highlight) {
		repeat()
	} else {
		var current_rot = d3.select(qbt).attr("transform")
		var interpol = d3.interpolateString( current_rot, `rotate(0,${cx},${cy})` )

		d3.select(qbt).transition()
			.duration(200)
			.attrTween("transform", function(d,i,a) { return interpol })
	}
}

var updateAll = function(data) {
	data.compute_syndrome()
	data.update_score_generators()
	renderAll(data)
}


var renderAll = function(data) {

	d3.select('#code').selectAll("*").remove() // why

	var code = d3.select("#code")
		.append("svg")
    .attr("width", width)
    .attr("height", height)
		// .call(d3.zoom().on("zoom", function () {
    //    code.attr("transform", d3.event.transform)
    // }))
		.append("g")

		for (var color in colors) {
			code.append('defs')
			.append('pattern')
			.attr('id', 'diagonal'+color)
			.attr('patternUnits', 'userSpaceOnUse')
			.attr('width', 4)
			.attr('height', 4)
			.append('rect')
			.attr('width', 4)
			.attr('height', 4)
			.attr('x', 0)
			.attr('x', 0)
			.attr('fill', colors[color] );

			d3.select('#diagonal'+color).append('path')
				.attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
				.attr('stroke', 'black')
				.attr('stroke-width', 0.75)
				.attr("opacity", 1);
		}

	var vv_row = code
		.append("g")
		.selectAll(".vv_row")
		.data(data.vv)
		.enter()
		.append("g")
		.attr("class", "vv_row");
	
	var vv_column = vv_row.selectAll(".vv_qubit")
		.data(function(d) { return d; })
		.enter().append("rect")
		.attr("class", "vv_qubit")
		.attr("x", function(d) { return (d.xind) * width/(n+m+padding); })
		.attr("y", function(d) { return (d.yind) * height/(n+m+padding); })
		.attr("width", width/(n+m+padding))
		.attr("height", height/(n+m+padding))
		.attr("cx", function(d) { return (d.xind) * width/(n+m+padding) + width/(n+m+padding)/2 })
		.attr("cy", function(d) { return (d.yind) * height/(n+m+padding) + height/(n+m+padding)/2 })
		.style("fill", function (qbt) { return qubitFill(qbt, false) })
		.style("stroke", "#222")
		.on('mouseover', function (qbt) {
				d3.select(this).style('fill', qubitFill(qbt, true))
				qbt.z_gen_nbhd.map(function (gen) {
					d3.select(z_gen_column._groups[qbt.yind][gen]).style('fill', syndFill(data.z_gens[qbt.yind][gen], true))
				})
			})
			.on('mouseout', function (qbt) {
				d3.select(this).style("fill", qubitFill(qbt, false))
				qbt.z_gen_nbhd.map(function (gen) {
					d3.select(z_gen_column._groups[qbt.yind][gen]).style('fill', syndFill(data.z_gens[qbt.yind][gen], false))
				})
			})
			.on('click', function(qbt) {
				qbt.in_error = !qbt.in_error
				updateAll(data)
			})

// -------------------------------------------------------------

	var cc_row = code
		.append("g")
		.selectAll(".cc_row")
		.data(data.cc)
		.enter().append("g")
		.attr("class", "cc_row")

	var cc_column = cc_row.selectAll(".cc_qubit")
		.data(function(d) { return d; })
		.enter().append("rect")
		.attr("class", "cc_qubit")
		.attr("x", function(d) { return (d.xind+n+padding) * width/(n+m+padding); })
		.attr("y", function(d) { return (d.yind+n+padding) * height/(n+m+padding); })
		.attr("width", width/(n+m+padding))
		.attr("height", height/(n+m+padding))
		.attr("cx", function(d) { return (d.xind+n+padding) * width/(n+m+padding) + width/(n+m+padding)/2 })
		.attr("cy", function(d) { return (d.yind+n+padding) * height/(n+m+padding) + height/(n+m+padding)/2 })
		.style("fill", function (qbt) { return qubitFill(qbt, false) })
		.style("stroke", "#222")
		.on('mouseover', function (qbt) {
			d3.select(this).style('fill', qubitFill(qbt, true))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[gen][qbt.xind]).style('fill', syndFill(data.z_gens[gen][qbt.xind], true))
			})
		})
		.on('mouseout', function (qbt) {
			d3.select(this).style("fill", qubitFill(qbt, false))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[gen][qbt.xind]).style('fill', syndFill(data.z_gens[gen][qbt.xind], false))
			})
		})
		.on('click', function(qbt) {
			qbt.in_error = !qbt.in_error
			updateAll(data)
		})

// -------------------------------------------------------------

	var z_gen_row = code
		.append("g")
		.selectAll(".z_gen_row")
		.data(data.z_gens)
		.enter().append("g")
		.attr("class", "z_gen_row")

	var z_gen_column = z_gen_row.selectAll(".z_gen")
		.data(function(d) {return d})
		.enter().append("rect")
		.attr("class", "z_gen")
		.attr("x", function(d) { return (d.xind+n+padding) * width/(n+m+padding); })
		.attr("y", function(d) { return (d.yind) * height/(n+m+padding); })
		.attr("width", width/(n+m+padding))
		.attr("height", height/(n+m+padding))
		.style("fill", function(gen) { return syndFill(gen, false) })
		.style("stroke", "#222")
		.on('mouseover', function (gen) {
				d3.select(this).style("fill", syndFill(gen, true))
				gen.vv_nbhd.map(function (qbt) {
					d3.select(vv_column._groups[gen.yind][qbt]).style('fill', qubitFill(data.vv[gen.yind][qbt], true))
				})
				gen.cc_nbhd.map(function (qbt) {
					d3.select(cc_column._groups[qbt][gen.xind]).style('fill', qubitFill(data.cc[qbt][gen.xind], true))
				})
			})
			.on('mouseout', function (gen) {
				d3.select(this).style("fill", syndFill(gen, false))
				gen.vv_nbhd.map(function (qbt) {
					d3.select(vv_column._groups[gen.yind][qbt]).style('fill', qubitFill(data.vv[gen.yind][qbt], false))
				})
				gen.cc_nbhd.map(function (qbt) {
					d3.select(cc_column._groups[qbt][gen.xind]).style('fill', qubitFill(data.cc[qbt][gen.xind], false))
				})
			})
			.on('click', function(gen) {
				gen.in_mask = !gen.in_mask
				updateAll(data)
			})

// -------------------------------------------------------------

	var x_gen_row = code
		.append("g")
		.selectAll(".x_gen_row")
		.data(data.x_gens)
		.enter().append("g")
		.attr("class", "x_gen_row")

	var x_gen_column = x_gen_row.selectAll(".x_gen")
		.data(function(d) {return d})
		.enter().append("rect")
		.attr("class", "x_gen")
		.attr("x", function(d) { return (d.xind) * width/(n+m+padding); })
		.attr("y", function(d) { return (d.yind+n+padding) * height/(n+m+padding); })
		.attr("width", width/(n+m+padding))
		.attr("height", height/(n+m+padding))
		.style("fill", function(d) { return myColor(d.score.best_synd_diff/d.score.best_weight)})
		.style("stroke", "#222")
		.on('mouseover', function(gen) { x_gen_mouseover(gen) })
		.on('mouseout', function(gen) { x_gen_mouseout(gen) })
		.on('click', function(gen) { x_gen_click(gen) })


	var x_gen_mouseover = function(gen) {
		// d3.select(this).style("fill", syndFill(gen, true))

		gen.vv_nbhd.map(function (qbt, i) {
			var vv_qbt = data.vv[qbt][gen.xind]
			var vv_qbt_render = vv_column._groups[qbt][gen.xind]
			cx = d3.select(vv_qbt_render).attr("cx")
			cy = d3.select(vv_qbt_render).attr("cy")

			d3.select(vv_qbt_render).style('fill', qubitFill(vv_qbt, true))

			if (gen.score.best_flips.ver_flips.includes(i) && gen.score.best_synd_diff) {
				d3.select(vv_qbt_render).raise()
				d3.select(vv_qbt_render.parentNode).raise()
				selectedSmallSet(vv_qbt_render, cx, cy, true)
			}
			vv_qbt.z_gen_nbhd.map(function (gen2) {
				d3.select(z_gen_column._groups[vv_qbt.yind][gen2]).style('fill', syndFill(data.z_gens[vv_qbt.yind][gen2], true))
			})
		})
		gen.cc_nbhd.map(function (qbt, i) {
			var cc_qbt = data.cc[gen.yind][qbt]
			var cc_qbt_render = cc_column._groups[gen.yind][qbt]
			cx = d3.select(cc_qbt_render).attr("cx")
			cy = d3.select(cc_qbt_render).attr("cy")

			d3.select(cc_qbt_render).style('fill', qubitFill(cc_qbt, true))

			if (gen.score.best_flips.hor_flips.includes(i) && gen.score.best_synd_diff) {
				d3.select(cc_qbt_render).raise()
				d3.select(cc_qbt_render.parentNode).raise()
				selectedSmallSet(cc_qbt_render, cx, cy, true)
			}
		})
	}

	var x_gen_mouseout = function(gen) {
	// d3.select(this).style("fill", syndFill(gen, false))
		gen.vv_nbhd.map(function (qbt, i) {
			var vv_qbt = data.vv[qbt][gen.xind]
			var vv_qbt_render = vv_column._groups[qbt][gen.xind]
			cx = d3.select(vv_qbt_render).attr("cx")
			cy = d3.select(vv_qbt_render).attr("cy")

			d3.select(vv_qbt_render).style('fill', qubitFill(vv_qbt, false))
			if (gen.score.best_flips.ver_flips.includes(i) && gen.score.best_synd_diff) {
				selectedSmallSet(vv_qbt_render, cx, cy, false)
			}
			vv_qbt.z_gen_nbhd.map(function (gen2) {
				d3.select(z_gen_column._groups[vv_qbt.yind][gen2]).style('fill', syndFill(data.z_gens[vv_qbt.yind][gen2], false))
			})
		})
		gen.cc_nbhd.map(function (qbt, i) {
			var cc_qbt = data.cc[gen.yind][qbt]
			var cc_qbt_render = cc_column._groups[gen.yind][qbt]
			cx = d3.select(cc_qbt_render).attr("cx")
			cy = d3.select(cc_qbt_render).attr("cy")

			d3.select(cc_qbt_render).style('fill', qubitFill(cc_qbt, false))
			if (gen.score.best_flips.hor_flips.includes(i) && gen.score.best_synd_diff) {
				selectedSmallSet(cc_qbt_render, cx, cy, false)
			}
		})
	}

	var x_gen_click = function(gen) {
		data.apply_gen(gen)
		updateAll(data)
	}

// --------------------------------------------------------

	d3.select('.right').selectAll("*").remove() // why
	var ranking = d3.select(".right")
		.append("div")
		.attr("id", "halfpage")
		.append("svg")
		.attr("id", "sky")
		.attr("height", 100*35)

	var sorted_data = data.x_gens.flat()
		.sort((a, b) => (a.score.best_synd_diff/a.score.best_weight) - (b.score.best_synd_diff/b.score.best_weight))
		.reverse()

	var rankings = ranking.selectAll(".ranks")
		.data(sorted_data.slice(0,100))
		.enter()
		.append("g")
		.on("mouseover", function(gen) { x_gen_mouseover(data.x_gens[gen.yind][gen.xind])	})
		.on("mouseout", function(gen) { x_gen_mouseout(data.x_gens[gen.yind][gen.xind]) })
		.on("click", function(gen) { x_gen_click(data.x_gens[gen.yind][gen.xind]) })

	rankings.append("rect")
		.attr("width", 140) // fill container
		.attr("height", 30) // just define
		.attr("x", 3)
		.attr("stroke", "black")
		.attr("fill", "white")
		// .attr("rx", 7)
		// .transition()
		// .duration(500)
		.attr("y", function(d, i) {
			return 35 * i // this can be determined by their ranking score
		})

	rankings.append("rect")
		.attr("width", 10) 
		.attr("height", 28) // just define
		.attr("x", 4)
		.style("fill", function(d) { return myColor(d.score.best_synd_diff/d.score.best_weight)})
		// .transition()
		// .duration(500)
		.attr("y", function(d, i) {
			return 35 * i + 1 // this can be determined by their ranking score
		})

	rankings.append("text")
		.text(function(d) { return d.score.best_synd_diff + " | " + (d.score.best_synd_diff ? d.score.best_weight : "0") })
		.style("font-size", "20px")
		.attr("x", 20)
		// .transition()
		// .duration(500)
		.attr("y", function(d, i) { return 35 * i + 21})
}

// var {vv_column, cc_column, z_gen_column, x_gen_column } = renderCode(lt)
renderAll(lt)

</script>


<!-- 

	var bit_nbhd = [[
	30,22,5,26,34],
[3,4,10,26,31],
[23,11,4,17,28],
[25,8,3,29,32],
[35,31,30,33,6],
[21,37,23,8,30],
[21,0,34,12,39],
[26,7,8,36,38],
[24,34,13,7,9],
[1,28,34,15,25],
[9,21,28,10,6],
[13,1,37,3,38],
[20,1,12,26,33],
[5,3,39,20,7],
[18,1,21,24,11],
[0,7,16,25,17],
[31,28,8,13,5],
[36,19,4,0,15],
[9,38,16,12,19],
[35,18,2,10,14],
[17,19,34,3,6],
[14,4,37,16,20],
[12,36,6,11,5],
[13,18,16,15,30],
[30,9,11,14,3],
[12,30,32,4,2],
[23,9,39,33,32],
[4,29,18,7,6],
[33,28,7,22,14],
[20,0,11,10,27],
[23,16,27,6,2],
[22,38,21,17,35],
[18,9,22,8,0],
[18,34,37,36,31],
[24,25,38,10,5],
[24,15,32,20,17],
[19,24,26,2,39],
[27,29,17,5,33],
[14,27,13,36,32],
[29,21,19,31,20],
[39,22,31,27,15],
[10,1,8,16,39],
[37,27,24,35,12],
[23,19,35,25,13],
[26,28,0,32,35],
[11,25,37,2,33],
[14,29,23,38,15],
[22,36,2,1,29],
	]

	var check_nbhd = [
	[6,15,29,17,44,32],
[14,11,9,47,41,12],
[47,30,19,25,36,45],
[1,13,20,11,24,3],
[2,1,21,25,17,27],
[13,22,0,34,16,37],
[30,20,22,10,27,4],
[28,15,27,13,8,7],
[16,7,3,32,5,41],
[24,26,18,32,10,8],
[41,19,10,29,1,34],
[45,2,24,29,22,14],
[42,12,22,6,18,25],
[23,16,38,8,11,43],
[21,24,38,19,46,28],
[40,46,35,9,17,23],
[30,15,18,21,23,41],
[37,15,31,20,35,2],
[33,32,19,14,23,27],
[43,18,36,39,20,17],
[29,13,39,35,21,12],
[39,6,5,14,31,10],
[31,0,47,40,32,28],
[2,30,5,43,46,26],
[14,35,34,8,36,42],
[34,3,15,45,43,9],
[0,1,12,44,36,7],
[37,42,30,38,29,40],
[28,16,9,10,44,2],
[27,39,37,46,3,47],
[4,0,23,5,25,24],
[16,39,4,33,1,40],
[26,35,38,25,44,3],
[12,45,28,4,37,26],
[0,9,6,20,33,8],
[19,4,43,31,42,44],
[22,38,17,7,47,33],
[42,11,45,5,33,21],
[11,34,46,31,7,18],
[13,40,41,26,36,6],
	]


		var bit_nbhd = [
	[5,7,10],
	[0,7,11],
	[2,5,8],
	[4,5,6],
	[1,6,11],
	[1,2,7],
	[2,3,11],
	[0,1,5],
	[0,3,10],
	[4,8,10],
	[9,10,11],
	[2,6,9],
	[0,8,9],
	[4,7,9],
	[3,6,8],
	[1,3,4,]
	]

	var check_nbhd = [
	[1,7,8,12],
	[4,5,7,15],
	[2,5,6,11],
	[6,8,14,15],
	[3,9,13,15],
	[0,2,3,7],
	[3,4,11,14],
	[0,1,5,13],
	[2,9,12,14],
	[10,11,12,13],
	[0,8,9,10],
	[1,4,6,10],
	]
 -->