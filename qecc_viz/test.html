<html>
	<head>
		<script src="https://d3js.org/d3.v4.js"></script>
		<script src="decoder.js"></script>
		<link rel="stylesheet" href="decoder.css"/>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
		<!-- <style>
			div#halfpage{
			height: 900px;
			width: 800px;
			border:2px solid #000;
			overflow-y: auto;
			}
			svg#sky {
				height: 1000px;
				width: 1100px;
				border:1px dotted #ccc;
				background-color: #ccc;
		 }
	</style> -->
	</head>
	<body>
		<div class="container">
			<div class="row">
				<div class="col-sm">
					<button type="button" onclick="randomError()">Generate error</button>
					<button type="button" onclick="randomMask()">Generate mask</button>
					<button type="button" onclick="test()">test</button>
				</div>
				<div class="col-sm">
					<div id="code" style="text-align: center"></div>
				</div>
				<div class="col-sm right">
				</div>
			</div>
		</div>

		


	</body>
</html>

<script>

function qcodeData(code) {
	var n = 16
	var m = 12

	var bit_nbhd = [
	[5,7,10],
	[0,7,11],
	[2,5,8],
	[4,5,6],
	[1,6,11],
	[1,2,7],
	[2,3,11],
	[0,1,5],
	[0,3,10],
	[4,8,10],
	[9,10,11],
	[2,6,9],
	[0,8,9],
	[4,7,9],
	[3,6,8],
	[1,3,4,]
	]

	var check_nbhd = [
	[1,7,8,12],
	[4,5,7,15],
	[2,5,6,11],
	[6,8,14,15],
	[3,9,13,15],
	[0,2,3,7],
	[3,4,11,14],
	[0,1,5,13],
	[2,9,12,14],
	[10,11,12,13],
	[0,8,9,10],
	[1,4,6,10],
	]

	var vv = new Array()
	var cc = new Array()
	var z_gens = new Array()
	var x_gens = new Array()

	for (var i = 0; i < n; i++) {
		vv.push(new Array())
		for (var j = 0; j < n; j++) {
			vv[i].push({
				xind: j,
				yind: i,
				z_gen_nbhd: bit_nbhd[j],
				x_gen_nbhd: bit_nbhd[i],
				in_error: 0
			})
		}
	}

	for (var i = 0; i < m; i++) {
		cc.push(new Array())
		for (var j = 0; j < m; j++) {
			cc[i].push({
				xind: j,
				yind: i,
				z_gen_nbhd: check_nbhd[i],
				x_gen_nbhd: check_nbhd[j],
				in_error: 0
			})
		}
	}

	for (var i = 0; i < n; i++) {
		z_gens.push(new Array())
		for (var j = 0; j < m; j++) {
			z_gens[i].push({
				xind: j,
				yind: i,
				vv_nbhd: check_nbhd[j],
				cc_nbhd: bit_nbhd[i],
				in_synd: false,
				in_mask: false
			})
		}
	}

	for (var i = 0; i < m; i++) {
		x_gens.push(new Array())
		for (var j = 0; j < n; j++) {
			x_gens[i].push({
				xind: j,
				yind: i,
				vv_nbhd: check_nbhd[i],
				cc_nbhd: bit_nbhd[j],
				score: { best_flips: [], best_synd_diff: 0, best_wweight: 1 }
			})
		}
	}
	return {vv, cc, z_gens, x_gens}
}

var {vv, cc, z_gens, x_gens} = qcodeData()

let width = 600
let height = 600
var n = 16
var m = 12
let dc = 4
let dv = 3
let padding = 1.5

var code = d3.select("#code")
		.append("svg")
    .attr("width", width)
    .attr("height", height)
		// .call(d3.zoom().on("zoom", function () {
    //    code.attr("transform", d3.event.transform)
    // }))
		.append("g")


	// https://stackoverflow.com/questions/37429608/can-i-have-a-svg-pattern-with-background-color

var myColor = d3.scaleLinear()
	.range(["white", "#00A7FF"])
  .domain([0, 1])

let colors = {
	"DarkRed": "#F44336", // dark red
	"LightRed": "#F88A81", // light red
	"Gray": "#9E9E9E", // gray
	"White": "#FFFFFF"
}

for (var color in colors) {
	code.append('defs')
	.append('pattern')
	.attr('id', 'diagonal'+color)
	.attr('patternUnits', 'userSpaceOnUse')
	.attr('width', 4)
	.attr('height', 4)
	.append('rect')
	.attr('width', 4)
	.attr('height', 4)
	.attr('x', 0)
	.attr('x', 0)
	.attr('fill', colors[color] );

	d3.select('#diagonal'+color).append('path')
		.attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
		.attr('stroke', 'black')
		.attr('stroke-width', 0.75)
		.attr("opacity", 1);
}

var randomError = function() {
	var p = 0.01
	vv.flat().map(function(qbt) {
		qbt.in_error = (Math.random() < p)
		d3.select(vv_column._groups[qbt.yind][qbt.xind]).style('fill', qubitFill(qbt, false))
	})
	cc.flat().map(function(qbt) {
		qbt.in_error = (Math.random() < p)
		d3.select(cc_column._groups[qbt.yind][qbt.xind]).style('fill', qubitFill(qbt, false))
	})
	syndrome()
}

var randomMask = function () {
	var p = 0.1
	z_gens.flat().map(function(gen) {
		gen.in_mask = (Math.random() < p)
		d3.select(z_gen_column._groups[gen.yind][gen.xind]).style('fill', syndFill(gen, false))
	})
}

var syndFill = function(gen, highlight) { 
	if (highlight) {
		if (gen.in_synd && gen.in_mask) { 
			return "url(#diagonalDarkRed)" 
		} 
		else if (gen.in_synd && !gen.in_mask) { return colors["DarkRed"] }
		else if (!gen.in_synd && gen.in_mask) { 
			return "url(#diagonalGray)" 
		}
		else { return colors["Gray"] }
	} else {
		if (gen.in_synd && gen.in_mask) { 
			return "url(#diagonalLightRed)" 
		} 
		else if (gen.in_synd && !gen.in_mask) { return colors["LightRed"] }
		else if (!gen.in_synd && gen.in_mask) { 
			return "url(#diagonalWhite)" 
		}
		else { return colors["White"] }
	}
}

var qubitFill = function(qbt, highlight) {
	if (highlight) {
		if (qbt.in_error) {
			return colors["DarkRed"]
		} else {
			return colors["Gray"]
		}
	} else {
		if (qbt.in_error) {
			return colors["LightRed"]
		} else {
			return colors["White"]
		}
	}
}

let test = function() {
	for (let k = 0; k < m; k++) {
		for (let l = 0; l < n; l++) {
			gen = x_gens[k][l]

			let synd_gen = new Array()
			let synd_mask = new Array()
			for (let i = 0; i < dc; i++) {
				synd_gen.push(new Array())
				synd_mask.push(new Array())
				for (let j = 0; j < dv; j++) {
					synd_gen[i].push(z_gens[gen.vv_nbhd[i]][gen.cc_nbhd[j]].in_synd)
					synd_mask[i].push(z_gens[gen.vv_nbhd[i]][gen.cc_nbhd[j]].in_mask)
				}
			}

			gen.score = score_gen(synd_gen, synd_mask)
			d3.select(x_gen_column._groups[k][l]).style('fill', function(d) { return myColor(d.score.best_synd_diff/d.score.best_wweight)} )
		}
	}

	renderRankings()
}

var vv_row = code.selectAll(".vv_row")
	.data(vv)
	.enter().append("g")
	.attr("class", "vv_row");

var cc_row = code.selectAll(".cc_row")
	.data(cc)
	.enter().append("g")
	.attr("class", "cc_row")

var z_gen_row = code.selectAll(".z_gen_row")
	.data(z_gens)
	.enter().append("g")
	.attr("class", "z_gen_row")

var x_gen_row = code.selectAll(".x_gen_row")
	.data(x_gens)
	.enter().append("g")
	.attr("class", "x_gen_row")



let renderRankings = function() {
	d3.select('.right').selectAll("*").remove() // why
	var ranking = d3.select(".right")
		.append("div")
		.attr("id", "halfpage")
		.append("svg")
		.attr("id", "sky")
		.attr("height", n*m*35)

	var sorted_data = x_gens.flat()
		.sort((a, b) => (a.score.best_synd_diff/a.score.best_wweight) - (b.score.best_synd_diff/b.score.best_wweight))
		.reverse()

	var rankings = ranking.selectAll(".ranks")
		.data(sorted_data)
		.enter()
		.append("g")
		// .on("mouseover", function (gen) {
		// 	d3.select(x_gen_column._groups[gen.yind][gen.xind]).style('fill', 'red')
		// })
		// .on("mouseout", function(gen) {
		// 	d3.select(x_gen_column._groups[gen.yind][gen.xind]).style('fill', 'white')

		// })

	rankings.append("rect")
		.attr("width", 140) // fill container
		.attr("height", 30) // just define
		.attr("x", 3)
		.attr("stroke", "black")
		.attr("fill", "white")
		// .attr("rx", 7)
		.transition()
		.duration(500)
		.attr("y", function(d, i) {
			return 35 * i // this can be determined by their ranking score
		})

	rankings.append("rect")
		.attr("width", 10) 
		.attr("height", 28) // just define
		.attr("x", 4)
		.style("fill", function(d) { return myColor(d.score.best_synd_diff/d.score.best_wweight)})
		.transition()
		.duration(500)
		.attr("y", function(d, i) {
			return 35 * i + 1 // this can be determined by their ranking score
		})
	

	// rankings.append("text")
	// 	.text('\u0394(\u03C3, F)')
	// 	.style("font-size", "20px")
	// 	.attr("x", 0)
	// 	.attr("y", function(d, i) {
	// 		return 35 * i // this can be determined by their ranking score
	// 	})
	// 	// .style("fill", "black")

}

renderRankings()

	
	

var x_gen_column = x_gen_row.selectAll(".x_gen")
	.data(function(d) {return d})
	.enter().append("rect")
	.attr("class", "x_gen")
	.attr("x", function(d) { return (d.xind) * width/(n+m+padding); })
	.attr("y", function(d) { return (d.yind+n+padding) * height/(n+m+padding); })
	.attr("width", width/(n+m+padding))
	.attr("height", height/(n+m+padding))
	.style("fill", function(d) { return myColor(d.score.best_synd_diff/d.score.best_wweight)})
	.style("stroke", "#222")
	.on('mouseover', function (gen) {
			// d3.select(this).style("fill", syndFill(gen, true))
			gen.vv_nbhd.map(function (qbt) {
				vv_qbt = vv[qbt][gen.xind]
				d3.select(vv_column._groups[qbt][gen.xind]).style('fill', qubitFill(vv_qbt, true))
				vv_qbt.z_gen_nbhd.map(function (gen2) {
					d3.select(z_gen_column._groups[vv_qbt.yind][gen2]).style('fill', syndFill(z_gens[vv_qbt.yind][gen2], true))
				})
			})
			gen.cc_nbhd.map(function (qbt) {
				d3.select(cc_column._groups[gen.yind][qbt]).style('fill', qubitFill(cc[gen.yind][qbt], true))
			})
		})
		.on('mouseout', function (gen) {
			// d3.select(this).style("fill", syndFill(gen, false))
			gen.vv_nbhd.map(function (qbt) {
				vv_qbt = vv[qbt][gen.xind]
				d3.select(vv_column._groups[qbt][gen.xind]).style('fill', qubitFill(vv_qbt, false))
				vv_qbt.z_gen_nbhd.map(function (gen2) {
					d3.select(z_gen_column._groups[vv_qbt.yind][gen2]).style('fill', syndFill(z_gens[vv_qbt.yind][gen2], false))
				})
			})
			gen.cc_nbhd.map(function (qbt) {
				d3.select(cc_column._groups[gen.yind][qbt]).style('fill', qubitFill(cc[gen.yind][qbt], false))
			})
		})


var z_gen_column = z_gen_row.selectAll(".z_gen")
	.data(function(d) {return d})
	.enter().append("rect")
	.attr("class", "z_gen")
	.attr("x", function(d) { return (d.xind+n+padding) * width/(n+m+padding); })
	.attr("y", function(d) { return (d.yind) * height/(n+m+padding); })
	.attr("width", width/(n+m+padding))
	.attr("height", height/(n+m+padding))
	.style("fill", "#FFFFFF")
	.style("stroke", "#222")
	.on('mouseover', function (gen) {
			d3.select(this).style("fill", syndFill(gen, true))
			gen.vv_nbhd.map(function (qbt) {
				d3.select(vv_column._groups[gen.yind][qbt]).style('fill', qubitFill(vv[gen.yind][qbt], true))
			})
			gen.cc_nbhd.map(function (qbt) {
				d3.select(cc_column._groups[qbt][gen.xind]).style('fill', qubitFill(cc[qbt][gen.xind], true))
			})
		})
		.on('mouseout', function (gen) {
			d3.select(this).style("fill", syndFill(gen, false))
			gen.vv_nbhd.map(function (qbt) {
				d3.select(vv_column._groups[gen.yind][qbt]).style('fill', qubitFill(vv[gen.yind][qbt], false))
			})
			gen.cc_nbhd.map(function (qbt) {
				d3.select(cc_column._groups[qbt][gen.xind]).style('fill', qubitFill(cc[qbt][gen.xind], false))
			})
		})
		.on('click', function(gen) {
			gen.in_mask = !gen.in_mask
			d3.select(this).style("fill", syndFill(gen, true))
		})

	
var vv_column = vv_row.selectAll(".vv_qubit")
	.data(function(d) { return d; })
	.enter().append("rect")
	.attr("class", "vv_qubit")
	.attr("x", function(d) { return (d.xind) * width/(n+m+padding); })
	.attr("y", function(d) { return (d.yind) * height/(n+m+padding); })
	.attr("width", width/(n+m+padding))
	.attr("height", height/(n+m+padding))
	.style("fill", "#FFFFFF")
	.style("stroke", "#222")
	.on('mouseover', function (qbt) {
			d3.select(this).style('fill', qubitFill(qbt, true))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[qbt.yind][gen]).style('fill', syndFill(z_gens[qbt.yind][gen], true))
			})
		})
		.on('mouseout', function (qbt) {
			d3.select(this).style("fill", qubitFill(qbt, false))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[qbt.yind][gen]).style('fill', syndFill(z_gens[qbt.yind][gen], false))
			})
		})
		.on('click', function(qbt) {
			qbt.in_error = !qbt.in_error
			d3.select(this).style("fill", qubitFill(qbt, true))				
			syndrome()
		})


	var cc_column = cc_row.selectAll(".cc_qubit")
		.data(function(d) { return d; })
		.enter().append("rect")
		.attr("class", "cc_qubit")
		.attr("x", function(d) { return (d.xind+n+padding) * width/(n+m+padding); })
		.attr("y", function(d) { return (d.yind+n+padding) * height/(n+m+padding); })
		.attr("width", width/(n+m+padding))
		.attr("height", height/(n+m+padding))
		.style("fill", "#FFFFFF")
		.style("stroke", "#222")
		.on('mouseover', function (qbt) {
			d3.select(this).style('fill', qubitFill(qbt, true))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[gen][qbt.xind]).style('fill', syndFill(z_gens[gen][qbt.xind], true))
			})
		})
		.on('mouseout', function (qbt) {
			d3.select(this).style("fill", qubitFill(qbt, false))
			qbt.z_gen_nbhd.map(function (gen) {
				d3.select(z_gen_column._groups[gen][qbt.xind]).style('fill', syndFill(z_gens[gen][qbt.xind], false))
			})
		})
		.on('click', function(qbt) {
			qbt.in_error = !qbt.in_error
			d3.select(this).style("fill", qubitFill(qbt, true))
			syndrome()
		})

		
		var syndrome = function() {
			// clear syndrome
			z_gens.flat().map(function(gen) { gen.in_synd = false })

			cc.flat().map(function(qbt) {
				if (qbt.in_error) {
					qbt.z_gen_nbhd.map(function(yind) {
						z_gens[yind][qbt.xind].in_synd = !z_gens[yind][qbt.xind].in_synd
					})
				}
			})
			vv.flat().map(function(qbt) {
				if (qbt.in_error) {
					qbt.z_gen_nbhd.map(function(xind) {
						z_gens[qbt.yind][xind].in_synd = !z_gens[qbt.yind][xind].in_synd
					})
				}
			})
			d3.selectAll(".z_gen")
				.each(function(gen) {
					d3.select(this).style("fill", syndFill(gen, false))
				})
		}


</script>


<!-- 

	var bit_nbhd = [[
	30,22,5,26,34],
[3,4,10,26,31],
[23,11,4,17,28],
[25,8,3,29,32],
[35,31,30,33,6],
[21,37,23,8,30],
[21,0,34,12,39],
[26,7,8,36,38],
[24,34,13,7,9],
[1,28,34,15,25],
[9,21,28,10,6],
[13,1,37,3,38],
[20,1,12,26,33],
[5,3,39,20,7],
[18,1,21,24,11],
[0,7,16,25,17],
[31,28,8,13,5],
[36,19,4,0,15],
[9,38,16,12,19],
[35,18,2,10,14],
[17,19,34,3,6],
[14,4,37,16,20],
[12,36,6,11,5],
[13,18,16,15,30],
[30,9,11,14,3],
[12,30,32,4,2],
[23,9,39,33,32],
[4,29,18,7,6],
[33,28,7,22,14],
[20,0,11,10,27],
[23,16,27,6,2],
[22,38,21,17,35],
[18,9,22,8,0],
[18,34,37,36,31],
[24,25,38,10,5],
[24,15,32,20,17],
[19,24,26,2,39],
[27,29,17,5,33],
[14,27,13,36,32],
[29,21,19,31,20],
[39,22,31,27,15],
[10,1,8,16,39],
[37,27,24,35,12],
[23,19,35,25,13],
[26,28,0,32,35],
[11,25,37,2,33],
[14,29,23,38,15],
[22,36,2,1,29],
	]

	var check_nbhd = [
	[6,15,29,17,44,32],
[14,11,9,47,41,12],
[47,30,19,25,36,45],
[1,13,20,11,24,3],
[2,1,21,25,17,27],
[13,22,0,34,16,37],
[30,20,22,10,27,4],
[28,15,27,13,8,7],
[16,7,3,32,5,41],
[24,26,18,32,10,8],
[41,19,10,29,1,34],
[45,2,24,29,22,14],
[42,12,22,6,18,25],
[23,16,38,8,11,43],
[21,24,38,19,46,28],
[40,46,35,9,17,23],
[30,15,18,21,23,41],
[37,15,31,20,35,2],
[33,32,19,14,23,27],
[43,18,36,39,20,17],
[29,13,39,35,21,12],
[39,6,5,14,31,10],
[31,0,47,40,32,28],
[2,30,5,43,46,26],
[14,35,34,8,36,42],
[34,3,15,45,43,9],
[0,1,12,44,36,7],
[37,42,30,38,29,40],
[28,16,9,10,44,2],
[27,39,37,46,3,47],
[4,0,23,5,25,24],
[16,39,4,33,1,40],
[26,35,38,25,44,3],
[12,45,28,4,37,26],
[0,9,6,20,33,8],
[19,4,43,31,42,44],
[22,38,17,7,47,33],
[42,11,45,5,33,21],
[11,34,46,31,7,18],
[13,40,41,26,36,6],
	]
 -->